.. _condition_assignment:

Randomization and conditional logic
===========================================

Condition assignment and counterbalancing
------------------------------------------

Generally, you’ll want to show slightly different versions of the study
to different participants: perhaps you have a few different conditions,
and/or need to counterbalance the order of trials or left/right position
of stimuli. You have several options for how to handle this, depending on your preferences
and the complexity of your design:

1. Simple randomization using frame parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A lot of simple randomization, like showing stimuli or questions in a random order, can be achieved simply using frame parameters to select values from a list you define. See :ref:`Defining frame parameters to reuse or randomize values<Frame parameters>`.


2. Generating your study protocol using Javascript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You also have the option to provide a Javascript function that generates your study protocol programmatically. For complex counterbalancing designs, this may be simpler to reason about and debug than using randomizer frames (below) because you can define variables and write the step-by-step instructions for how to create the study protocol, without having to learn any special Lookit syntax. See :ref:`'Protocol generators'<generators>` for more information. 

A protocol generator function can do anything that a randomizer frame can do. But to set up :ref:`conditional logic<Conditional logic>` (doing different things depending on what the family does *this session*), you will still need to use ``generateProperties`` or ``selectNextFrame`` parameters within the protocol you generate. 


3. Randomizer frames
~~~~~~~~~~~~~~~~~~~~~~

You can also use a special frame called a
**randomizer** to select an appropriate sequence of frames for a
particular trial. A randomizer frame is automatically expanded to a list
of frames, so that for instance you can specify your 12 looking-time
trials all at once. 

See `here <https://lookit.github.io/lookit-frameplayer-docs/modules/randomizers.html>`_ for complete documentation of available randomizers. In addition to the general-purpose ``random-parameter-set`` randomizer we focus on here, there are randomizers for typical needs such as showing a set of frames in a random order.

To use a randomizer frame, set the frame ``"kind"`` to ``"choice"`` and
``"sampler"`` to the appropriate type of randomizer. 



.. _random_parameter_set:

The random-parameter-set randomizer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The most general randomizer type is called
`random-parameter-set <https://lookit.github.io/lookit-frameplayer-docs/classes/randomParameterSet.html>`_.

To select this randomizer, you need to define a frame that has the
appropriate ``"kind"`` and ``"sampler"``:

::

   {
       ...
       "frames": {
           ...
           "test-trials": {
               "sampler": "random-parameter-set",
               "kind": "choice",
               ...
           }
       }
   }

In addition, there are three special properties you need to define to
use ``random-parameter-set``: ``frameList``, ``commonFrameProperties``,
and ``parameterSets``.

**``frameList``** is just what it sounds like: a list of all the frames
that should be generated by this randomizer. Each frame is a JSON object
just like you would use in the overall schema, with two differences:

-  You can define default properties, to share across all of the frames
   generated by this randomizer, in the JSON object
   ``commonFrameProperties`` instead, as a convenience.

You can use placeholder strings for any of the properties in the frame;
they will be replaced based on the values in the selected
``parameterSet``.

**``parameterSets``** is a list of mappings from placeholder strings to
actual values. When a participant starts your study, one of these sets
will be randomly selected, and any parameter values in the ``frameList``
(including ``commonFrameProperties``) that match any of the keys in this
parameter set will be replaced.

Let’s walk through an example of using this randomizer. Suppose we start
with the following JSON document describing a study that includes
instructions, an experimental manipulation asking participants to think
about how delicious broccoli is, and an exit survey:

.. code:: json

   {
       "frames": {
          "instructions": {
              "id": "text-1",
              "blocks": [
                  {
                      "text": "Some introductory text about this study."
                  },
                  {
                      "text": "Here's what's going to happen! You're going to think about how tasty broccoli is."
                  }
              ],
              "showPreviousButton": false,
              "kind": "exp-lookit-text"
          },
          "manipulation": {
              "id": "text-2",
              "blocks": [
                  {
                      "text": "Think about how delicious broccoli is."
                  },
                  {
                      "text": "It is so tasty!"
                  }
              ],
              "showPreviousButton": true,
              "kind": "exp-lookit-text"
          },
          "exit-survey": {
               "debriefing": {
                   "text": "Thank you for participating in this study! ",
                   "title": "Thank you!"
               },
               "id": "exit-survey",
               "kind": "exp-lookit-exit-survey"
           }
       },
       "sequence": [
           "instructions",
           "manipulation",
           "exit-survey"
       ]
   }

But what we really want to do is have some kids think about how tasty
broccoli is, and others think about how yucky it is! We can use a
``random-parameter-set`` frame to replace both text frames:

.. code:: json

   {
       "frames": {
           "instruct-and-manip": {
               "sampler": "random-parameter-set",
               "kind": "choice",
               "id": "instruct-and-manip",
               "frameList": [
                   {
                      "blocks": [
                          {
                              "text": "Some introductory text about this study."
                          },
                          {
                              "text": "INTROTEXT"
                          }
                      ],
                      "showPreviousButton": false
                   },
                   {
                      "blocks": [
                          {
                              "text": "MANIP-TEXT-1"
                          },
                          {
                              "text": "MANIP-TEXT-2"
                          }
                      ],
                      "showPreviousButton": true
                  }
               ],
               "commonFrameProperties": {
                   "kind": "exp-lookit-text"
               },
               "parameterSets": [
                   {
                       "INTROTEXT": "Here's what's going to happen! You're going to think about how tasty broccoli is.",
                       "MANIP-TEXT-1": "Think about how delicious broccoli is.",
                       "MANIP-TEXT-2": "It is so tasty!"
                   },
                   {
                       "INTROTEXT": "Here's what's going to happen! You're going to think about how disgusting broccoli is.",
                       "MANIP-TEXT-1": "Think about how disgusting broccoli is.",
                       "MANIP-TEXT-2": "It is so yucky!"
                   }
               ]
           },
          "exit-survey": {
               "debriefing": {
                   "text": "Thank you for participating in this study! ",
                   "title": "Thank you!"
               },
               "id": "exit-survey",
               "kind": "exp-lookit-exit-survey"
           }
       },
       "sequence": [
           "instruct-and-manip",
           "exit-survey"
       ]
   }

Notice that since both of the frames in the ``frameList`` were of the
same kind, we could define the kind in ``commonFrameProperties``. We no
longer define ``id`` values for the frames, as they will be
automatically identified as ``instruct-and-manip-1`` and
``instruct-and-manip-2``.

When the “instruct-and-manip” randomizer is evaluated, the Lookit
experiment player will start with the frameList and add the key-value
pairs in commonFrameProperties to each frame (not overwriting existing
pairs):

.. code:: javascript

   [
       {
           "kind": "exp-lookit-text",
           "blocks": [
               {
                   "text": "Some introductory text about this study."
               },
               {
                   "text": "INTROTEXT"
               }
           ],
           "showPreviousButton": false
       },
       {
           "kind": "exp-lookit-text",
           "blocks": [
               {
                   "text": "MANIP-TEXT-1"
               },
               {
                   "text": "MANIP-TEXT-2"
               }
           ],
           "showPreviousButton": true
       }
   ]

Next, one of the two objects in ``parameterSets`` is selected randomly.
(By default, parameter sets are weighted equally, but
``parameterSetWeights`` can be provided as an optional key in the
``random-parameter-set`` frame. If provided, ``parameterSetWeights``
should be an array of relative weights for the parameter sets,
corresponding to the order they are listed. For instance, if we wanted
75% of participants to think about how tasty broccoli is, we could set
``parameterSetWeights`` to [3, 1]. This allows uneven condition
assignment where needed to optimize power, as well as allowing
researchers to stop testing conditions that already have enough
participants as data collection proceeds. 

.. admonition:: Advanced options for choosing the parameterSet

   You can `determine the weights based on the child's age <https://lookit.github.io/lookit-frameplayer-docs/classes/Random-parameter-set.html#property_parameterSetWeights>`_, to maintain balanced conditions.) You can also `keep kids in the same condition across all sessions they complete, or rotate them through conditions in order  <https://lookit.github.io/lookit-frameplayer-docs/classes/Random-parameter-set.html#property_conditionForAdditionalSessions>`_.

Suppose that in this case the second parameter set is selected:

.. code:: json

    {
    "INTROTEXT": "Here's what's going to happen! You're going to think about how disgusting broccoli is.",
    "MANIP-TEXT-1": "Think about how disgusting broccoli is.",
    "MANIP-TEXT-2": "It is so yucky!"
    }

Now we return to the list of frames, and wherever any value matches one
of the keys in the ``parameterSet`` (even if that value is nested in
another object), it is replaced by the corresponding value from the
``parameterSet``, yielding the following final list of frames:

::

   [
       {
           "kind": "exp-lookit-text",
           "blocks": [
               {
                   "text": "Some introductory text about this study."
               },
               {
                   "text": "Here's what's going to happen! You're going to think about how disgusting broccoli is."
               }
           ],
           "showPreviousButton": false
       },
       {
           "kind": "exp-lookit-text",
           "blocks": [
               {
                   "text": "Think about how disgusting broccoli is."
               },
               {
                   "text": "It is so yucky!"
               }
           ],
           "showPreviousButton": true
       }
   ]

Case study: 2 x 2 x 2 design
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Suppose you want to set up a study with a 2 x 2 x 2 design: that is, three types of things
vary, each with two options. For this toy example, all we want to do is tell a short 
background story. The conditions will be:

- Character name: JANE or JILL

- Animal type: The character has a DOG or a CAT

- Location: The character lives in the COUNTRY or in the CITY

You want to create a single ``exp-lookit-text`` frame like this:

::

    {
        "kind": "exp-lookit-text",
        "blocks": [
            {
                "text": "CHARACTER_INTRO_TEXT"
            },
            {
                "text": "ANIMAL_INTRO_TEXT"
            },
            {
                "text": "SETTING_TEXT"
            }
        ]
    }

You have a variety of options for how to accomplish random condition assignment:

1. You could use a ``random-parameter-set`` randomizer and simply list all 2 * 2 * 2 = 8 options. Eight is a lot to list manually, but it's not ridiculous. This gives you maximum flexibility if you want to stop running one particular combination, or balance out the particular combinations based on how many kids in sub-age-ranges have completed each version of your study:

::

    {
        "kind": "choice",
        "sampler": "random-parameter-set", 
        "frameList": [
            {
                "kind": "exp-lookit-text",
                "blocks": [
                    {
                        "text": "CHARACTER_INTRO_TEXT"
                    },
                    {
                        "text": "ANIMAL_INTRO_TEXT"
                    },
                    {
                        "text": "SETTING_TEXT"
                    }
                ]
            }
        ],
        "parameterSets": [
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jane.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her dog.",
                "SETTING_TEXT": "They lived in the middle of a big city."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jane.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her dog.",
                "SETTING_TEXT": "They lived out in the country."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jane.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her cat.",
                "SETTING_TEXT": "They lived in the middle of a big city."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jane.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her cat.",
                "SETTING_TEXT": "They lived out in the country."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jill.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her dog.",
                "SETTING_TEXT": "They lived in the middle of a big city."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jill.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her dog.",
                "SETTING_TEXT": "They lived out in the country."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jill.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her cat.",
                "SETTING_TEXT": "They lived in the middle of a big city."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jill.",
                "ANIMAL_INTRO_TEXT": "She went everywhere with her cat.",
                "SETTING_TEXT": "They lived out in the country."
            }
        ]
    }
    
2. If you don't want to deal with manually listing those combinations (for instance, because you're actually running a 2 x 2 x 2 x 2 x 2 design, or a 3 x 3 x 3 design...), you can use nested randomizers as discussed further below:

::

    {
        "kind": "choice",
        "sampler": "random-parameter-set", 
        "frameList": [
            {
                "kind": "choice",
                "sampler": "random-parameter-set", 
                "frameList": [
                    {
                        "kind": "choice",
                        "sampler": "random-parameter-set", 
                        "frameList": [
                            {
                                "kind": "exp-lookit-text",
                                "blocks": [
                                    {
                                        "text": "CHARACTER_INTRO_TEXT"
                                    },
                                    {
                                        "text": "ANIMAL_INTRO_TEXT"
                                    },
                                    {
                                        "text": "SETTING_TEXT"
                                    }
                                ]
                            }
                        ],
                        "parameterSets": [
                            {
                                "SETTING_TEXT": "They lived in the middle of a big city."
                            },
                            {
                                "SETTING_TEXT": "They lived out in the country."
                            }
                        ]
                    }
                ],
                "parameterSets": [
                    {
                        "ANIMAL_INTRO_TEXT": "She went everywhere with her cat."
                    },
                    {
                        "ANIMAL_INTRO_TEXT": "She went everywhere with her dog."
                    }
                ]
            }
        ],
        "parameterSets": [
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jane."
            },
            {
                "CHARACTER_INTRO_TEXT": "Once upon a time there was a girl named Jill."
            }
        ]
    }
    
3. You can use the ``#RAND`` syntax and `frame parameters <https://lookit.github.io/lookit-frameplayer-docs/classes/Exp-frame-base.html#property_parameters>`_ to substitute in one of the two options for each condition:

::

    {
        "kind": "exp-lookit-text",
        "blocks": [
            {
                "text": "CHARACTER_INTRO_TEXT_CHOICES#RAND"
            },
            {
                "text": "ANIMAL_INTRO_TEXT_CHOICES#RAND"
            },
            {
                "text": "SETTING_TEXT_CHOICES#RAND"
            }
        ],
        "parameters": {
            "CHARACTER_INTRO_TEXT_CHOICES": [
                "Once upon a time there was a girl named Jane.",
                "Once upon a time there was a girl named Jill."
            ],
            "ANIMAL_INTRO_TEXT_CHOICES": [
                "She went everywhere with her dog.",
                "She went everywhere with her cat."
            ],
            "SETTING_TEXT_CHOICES": [
                "They lived in the middle of a big city.",
                "They lived out in the country."
            ]
        }
    }
        
Real randomization will generally be somewhat more complex - rather than setting the text on a single frame, you might be selecting which set of images to use, selecting whether to include a training phase, etc. However, the basic principles will be the same, and if you understand the options above, you will likely have a good idea of how to set up your own study.


Nested randomizers
^^^^^^^^^^^^^^^^^^^^^^^^^^

In more complex experimental designs, the frames created by a randomizer
may themselves be frame groups or randomizers! This nesting allows more modular
specification: for instance, a study might have ten test trials, each of
which consists of three phases. The “outer” randomizer could then
generate a frameList of ten randomizer frames, each of which would be
resolved in turn into three frames. Below is a simplified example with
only two test trials, each of which has three phases:

Here’s an example. Notice that ``"kind": "choice"``,
``"sampler": "random-parameter-set"``, ``"frameList": ...``, and
``commonFrameProperties`` are ``commonFrameProperties`` of the outer
frame ``nested-trials``. That means that every “frame” we’ll create as
part of ``nested-trials`` will itself be a random-parameter-set
generated list with the same frame sequence, although we’ll be
substituting in different parameter values. (This doesn’t have to be the
case - we could show different types of frames in the list - but in the
simplest case where you’re using randomParameterSet just to group
similar repeated frame sequences, this is probably what you’d do.) The
only thing that differs across the two (outer-level) **trials** is the
``parameterSet`` used, and we list only one parameter set for each
trial, to describe (deterministically) how the outer-level
``parameterSet`` values should be applied to each particular frame.

.. code:: json

   {
         "sampler": "random-parameter-set",
         "frameList": [
           {
             "parameterSets": [
                {
                  "NTRIAL": 1,
              "PHASE1STIM": "T1P1",
              "PHASE2STIM": "T1P2",
              "PHASE3STIM": "T1P3"
                }
             ]
           },
           {
             "parameterSets": [
                {
                  "NTRIAL": 2,
              "PHASE1STIM": "T2P1",
              "PHASE2STIM": "T2P2",
              "PHASE3STIM": "T2P3"
                }
             ]
           }
         ],
         "parameterSets": [
           {
               "T1P1": "mouse",
               "T1P2": "rat",
               "T1P3": "chipmunk",
               "T2P1": "horse",
               "T2P2": "goat",
               "T2P3": "cow"
           },
           {
               "T1P1": "guppy",
               "T1P2": "tadpole",
               "T1P3": "goldfish",
               "T2P1": "whale",
               "T2P2": "manatee",
               "T2P3": "shark"
           }

         ],
         "commonFrameProperties": {
            "sampler": "random-parameter-set",
            "frameList": [
                   {
                       "nPhase": 1,
                   "animal": "PHASE1STIM"
                   },
                   {
                       "nPhase": 2,
                   "animal": "PHASE2STIM"
                   },
                   {
                       "nPhase": 3,
                   "animal": "PHASE3STIM"
                   }
            ],
            "commonFrameProperties": {
              "nTrial": "NTRIAL",
              "kind": "question-about-animals-frame"
            }
         }
   }

To evaluate this experiment frame, the Lookit experiment player starts
with the list of frames in the outer ``frameList``, adding the key:value
pairs in the outer ``commonFrameProperties`` to each frame, which yields
the following list of frames:

::

   [
           {
           "parameterSets": [
                   {
                       "NTRIAL": 1,
                   "PHASE1STIM": "T1P1",
                   "PHASE2STIM": "T1P2",
                   "PHASE3STIM": "T1P3"
                }
             ],
           "sampler": "random-parameter-set",
           "frameList": [
               {
                   "nPhase": 1,
               "animal": "PHASE1STIM"
               },
               {
                   "nPhase": 2,
               "animal": "PHASE2STIM"
               },
               {
                   "nPhase": 3,
               "animal": "PHASE3STIM"
               }
           ],
           "commonFrameProperties": {
               "nTrial": "NTRIAL",
               "kind": "question-about-animals-frame"
           }
           },
           {
               "parameterSets": [
                   {
                       "NTRIAL": 2,
                   "PHASE1STIM": "T2P1",
                   "PHASE2STIM": "T2P2",
                   "PHASE3STIM": "T2P3"
                   }
               ],
           "sampler": "random-parameter-set",
           "frameList": [
               {
                   "nPhase": 1,
               "animal": "PHASE1STIM"
               },
               {
                   "nPhase": 2,
               "animal": "PHASE2STIM"
               },
               {
                   "nPhase": 3,
               "animal": "PHASE3STIM"
               }
           ],
           "commonFrameProperties": {
               "nTrial": "NTRIAL",
               "kind": "question-about-animals-frame"
           }
       }
   ]

One of the two (outer) ``parameterSets`` is then selected randomly;
suppose the second one (aquatic instead of land animals) is selected.
Now any substitutions are made based on the keys in this parameterSet.
The first frame in the sequence is now:

.. code:: json

       {
           "parameterSets": [
                   {
                       "NTRIAL": 1,
                   "PHASE1STIM": "guppy",
                   "PHASE2STIM": "tadpole",
                   "PHASE3STIM": "goldfish"
                }
             ],
           "sampler": "random-parameter-set",
           "frameList": [
               {
                   "nPhase": 1,
               "animal": "PHASE1STIM"
               },
               {
                   "nPhase": 2,
               "animal": "PHASE2STIM"
               },
               {
                   "nPhase": 3,
               "animal": "PHASE3STIM"
               }
           ],
           "commonFrameProperties": {
               "nTrial": "NTRIAL",
               "kind": "question-about-animals-frame"
           }
       }

Next, each frame is expanded since it is in turn another randomizer (due
to ``"sampler": "random-parameter-set"``). The frame above, representing
Trial 1, will be turned into three frames. First, again, we start with
the ``frameList``, and merge the ``commonFrameProperties`` into each
frame:

::

    [
       {
           "nPhase": 1,
           "animal": "PHASE1STIM",
           "nTrial": "NTRIAL",
               "kind": "question-about-animals-frame"
       },
       {
           "nPhase": 2,
           "animal": "PHASE2STIM",
           "nTrial": "NTRIAL",
               "kind": "question-about-animals-frame"
       },
       {
           "nPhase": 3,
           "animal": "PHASE3STIM",
           "nTrial": "NTRIAL",
               "kind": "question-about-animals-frame"
       }
   ]

Finally, a parameter set is selected from ``parameterSets``. Only one
parameter set is defined for this trial, which is deliberate; it simply
selects the correct stimuli for this trial. Substituting in the values
from the parameter set yields the following list of frames:

::

   [
       {
           "nPhase": 1,
           "animal": "guppy",
           "nTrial": 1,
               "kind": "question-about-animals-frame"
       },
       {
           "nPhase": 2,
           "animal": "tadpole",
           "nTrial": 1,
               "kind": "question-about-animals-frame"
       },
       {
           "nPhase": 3,
           "animal": "goldfish",
           "nTrial": 1,
               "kind": "question-about-animals-frame"
       }
   ]

The ``random-parameter-set`` randomizer is expected to be general enough
to capture most experimental designs that researchers put on Lookit, but
additional more specific randomizers will also be designed to provide
simpler syntax for common use cases.


.. _Conditional logic:

Conditional logic
-----------------

In some cases, what happens next in your study will need to depend on what has happened so far, what happened during previous sessions of the study, and/or information about the participant. For instance, perhaps you want to move on from a training segment after the participant answers three questions in a row correctly, or you want to start with an eligibility survey and only route people to the rest of the study if they meet detailed criteria. Or maybe you just want to personalize instructions or stimuli with the child's name and gender! All Lookit frames allow you to provide either or both of the following properties to flexibly specify conditional behavior:

1. `generateProperties <https://lookit.github.io/lookit-frameplayer-docs/classes/Exp-frame-base.html#property_generateProperties>`_: Provide a function that takes ``expData``, ``sequence``, ``child``, ``pastSessions``, and ``conditions`` objects, and returns an object representing any additional properties that should be used by this frame - e.g., the frame type, text blocks, whether to do recording, etc. (In principle a ``generateProperties`` function could conditionally assign ``selectNextFrame``, although we do not know of a use case where this is necessary.)

2. `selectNextFrame <https://lookit.github.io/lookit-frameplayer-docs/classes/Exp-frame-base.html#property_selectNextFrame>`_: Provide a function that takes ``frames``, ``frameIndex``, ``expData``, ``sequence``, ``child``, and ``pastSessions`` and returns that frame index to go to when using the 'next' action on this frame. For instance, this allows you to skip to the end of the study (or a frame of a particular type) if the child has gotten several questions correct.

Each of these properties is specified as a string, which must define a Javascript function of the specified arguments. ``generateProperties`` is called when the frame is initialized, and ``selectNextFrame`` is called upon proceeding to the next frame. 

Formal documentation for these properties is linked above. However, in practice, if you want to add some conditional behavior and are wondering e.g. how to get the child's first name or birthday, or how to determine what condition the child is in, it may be easiest to get started by adding a dummy function like the following to the frame in question:

.. code:: json

        "generateProperties": "function(expData, sequence, child, pastSessions, conditions) {console.log(expData); console.log(sequence); console.log(child); console.log(pastSessions); console.log(conditions); return {};}" 
        
        "selectNextFrame": "function(frames, frameIndex, frameData, expData, sequence, child, pastSessions) {console.log(frames); console.log(frameIndex); console.log(frameData); console.log(expData); console.log(sequence); console.log(child); console.log(pastSessions); return (frameIndex + 1);}" 
        
These functions just log each of the arguments they're given the Javascript console; there you can take a look and play around with how you'd access and manipulate the properties you need. The ``generateProperties`` function above just return an empty object, not assigning any properties. The ``selectNextFrame`` function just returns ``frameIndex + 1``, i.e. says the next frame should be the one after this one, not changing the frame's regular behavior.

Although you'll need to enter these properties as single-line strings in the Lookit study editor, they are obviously not very readable that way! You can go from a single-line string back to something readable using a Javascript 'beautifier' like `this <https://beautifier.io/>`__ - you may want to do that to better understand the examples below. When you are writing your own functions, you can write them on multiple lines in your text editor and then either strip out the line breaks using your text editor or one of many online tools like `this <https://lingojam.com/TexttoOneLine>`__.


Example: eligibility survey
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here is an example of a situation where you might want to determine the sequence of frames in a study and/or behavior of those frames based on data collected earlier in the study. Suppose you want to start off with a survey to determine eligibility, using criteria that go beyond what is available in Lookit child/demographic surveys and usable for automatic eligibility detection. (Perhaps your study is very involved or won't make sense to people who don't meet criteria, so you don't want to just have everyone participate and filter the data afterwards.)

A similar approach would be appropriate if you wanted to customize the behavior of the study based on user input - e.g., using the child's favorite color for stimuli, let the family choose which game they want to play this time, or let the family choose whether to 'actually' participate (and have video recorded) or just see a demo.

This example has three top-level frames: an eligibility survey, a study procedure (which depends on eligibility as determined from the survey), and an exit survey (with debriefing text that depends on eligibility too). 

.. code:: json

        {
            "frames": {
                "exit-survey": {
                    "kind": "exp-lookit-exit-survey",
                    "generateProperties": "function(expData, sequence, child, pastSessions) {var eligible = expData['1-study-procedure']['generatedProperties']['ELIGIBLE']; if (eligible) { return { 'debriefing': {                 'text': 'In this study, we were looking at why babies love cats. Your child actually participated. A real debriefing would be more detailed.', 'title': 'Thank you!' } }; } else { return { 'debriefing': {                 'text': 'In this study, we would have looked at why your child loved cats. Your child did not actually participate though. A real debriefing would make more sense.', 'title': 'Thank you!' } }; }}"
                },
                "eligibility-survey": {
                    "kind": "exp-lookit-survey",
                    "formSchema": {
                        "schema": {
                            "type": "object",
                            "title": "Eligibility survey",
                            "properties": {
                                "nCats": {
                                    "type": "integer",
                                    "title": "How many cats do you have?",
                                    "maximum": 200,
                                    "minimum": 0,
                                    "required": true
                                },
                                "loveCats": {
                                    "enum": [
                                        "yes",
                                        "no"
                                    ],
                                    "type": "string",
                                    "title": "Does your baby love cats?",
                                    "required": true
                                }
                            }
                        },
                        "options": {
                            "fields": {
                                "nCats": {
                                    "numericEntry": true
                                },
                                "loveCats": {
                                    "type": "radio",
                                    "message": "Please answer this question.",
                                    "validator": "required-field"
                                }
                            }
                        }
                    },
                    "nextButtonText": "Continue"
                },
                "study-procedure": {
                    "kind": "exp-frame-select",
                    "frameOptions": [
                        {
                            "kind": "exp-frame-select",
                            "frameOptions": [
                                {
                                    "kind": "exp-lookit-text",
                                    "blocks": [
                                        {
                                            "emph": true,
                                            "text": "Let's start the study!"
                                        },
                                        {
                                            "text": "Some info about cats..."
                                        }
                                    ]
                                },
                                {
                                    "kind": "exp-lookit-text",
                                    "blocks": [
                                        {
                                            "emph": true,
                                            "text": "Cats are great"
                                        },
                                        {
                                            "text": "We are measuring how much your child loves cats now. Beep boop!"
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            "kind": "exp-lookit-text",
                            "blocks": [{
                                    "emph": true,
                                    "text": "Your child is not eligible for this study"
                                },
                                {
                                    "text": "Either you do not have any cats or your child does not love cats."
                                }
                            ]
                        }
                    ],
                    "generateProperties": "function(expData, sequence, child, pastSessions) {var formData = expData['0-eligibility-survey'].formData; if (formData.nCats >= 1 && formData.loveCats == 'yes') { console.log('eligible'); return { 'whichFrames': 0, 'ELIGIBLE': true } } else { console.log('ineligible'); return { 'whichFrames': 1,  'ELIGIBLE': false } } }"
                }
            },
            "sequence": [
                "eligibility-survey",
                "study-procedure",
                "exit-survey"
            ]
        }
        
Here's how it works:

1. The study procedure is set up as `an exp-frame-select frame <https://lookit.github.io/lookit-frameplayer-docs/classes/Exp-frame-select.html>`_, and we decide on-the-spot which of the two ``frameOptions`` to use based on the data in the survey by providing a ``generateProperties`` function that returns a value for ``whichFrames``. The function ``generateProperties`` is called when we get to the ``study-procedure`` frame, and the key-value pairs it returns get added to the other parameters for this frame (like ``kind`` and ``frameOptions``). In this case, it checks to see whether the survey says the family has at least one cat *and* the child loves cats; in that case, the child is eligible to participate. 

   Additionally, the object ``generateProperties`` returns is stored under the key ``generatedProperties`` in expData for this frame, so that we can use the output later. That's why we also include either ``'ELIGIBLE': true`` or ``'ELIGIBLE': false`` - that way we can reuse this determination later on in another ``generateProperties`` function.
   
2. If the child isn't eligible, the ``study-procedure`` frame just resolves to a single ``exp-lookit-text`` frame, at index 1 of ``frameOptions``. If the child is eligible, the ``study-procedure`` frame resolves to a second ``exp-frame-select`` frame, which just serves to bundle up a few text frames. We don't provide ``whichFrames``, so all of the ``frameOptions`` listed will be shown in order. (We could also have set this up without a nested ``exp-frame-select`` frame, e.g. by putting all three ``exp-lookit-text`` frames in the outer ``frameOptions`` and saying that if the child is eligible, use ``whichFrames = [0, 1]``, and if not, ``whichFrames = 2``.)

3. After the study procedure is done, everyone goes to an exit survey. The ``generateProperties`` function of the exit survey returns different debriefing text based on the stored ``ELIGIBLE`` value we defined earlier. 

Note that the data stored in ``expData``` will include frame data for the ``exp-frame-select`` frames, even though these are not actually displayed as frames separate from the contents they resolve to. For a child who is eligible, the keys in ``expData`` will be:

- ``0-eligibility-survey``
- ``1-study-procedure`` (the outer ``exp-frame-select`` frame)
- ``1-study-procedure-0`` (the inner ``exp-frame-select`` frame)
- ``1-study-procedure-0-0`` (the first ``exp-lookit-text`` frame)
- ``1-study-procedure-0-1`` (the second ``exp-lookit-text`` frame)


Example: skipping a survey if it was completed previously
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose your list of frames includes ``instructions``, ``eligibility-survey``, ``detailed-survey``, and ``test-trial``, in that order. You want to show all of these frames in order in general (although you’ll skip straight from eligibility-survey to test-trial if the person completing the study is not eligible to complete the detailed-survey). But if someone has already completed the detailed-survey, you want to skip straight from instructions to test-trial. You can do that by adding the following to the JSON specification for the instructions frame:

.. code:: json

    "selectNextFrame": "function(frames, frameIndex, frameData, expData, sequence, child, pastSessions) {if (pastSessions.some(sess => Object.keys(sess.get('expData', {})).some(frId => frId.endsWith('-detailed-survey')))) {return frameIndex + 3;} else {return frameIndex + 1;}}"
    
What this does is check to see if the ``pastSessions`` data contains any session with expData for a ``*-detailed-survey`` frame. If so, it sets the "next" frame to this frame + 3 - i.e., instead of incrementing by 1, it increments by 3, so it skips the two survey frames.


Example: waiting for successful training
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, you might want to skip ahead to the next section of an experiment once certain
criteria are met. For instance:

- you might have a study where questions get harder and harder over time, and you just want to keep asking until the child gets N wrong in a row
- you might want to have a "training" section that allows the family to practice until they're ready
- you might want to make one section of a study optional, and skip over it if the parent opts to (or if it's not applicable to them)

Here's an example study where we wait for the child to get two "training" questions right, then proceed to a "test" question:

.. code:: json

        {
            "frames": {
                "exit-survey": {
                    "kind": "exp-lookit-exit-survey",
                    "debriefing": {
                        "title": "Thank you!",
                        "text": "Thank you for participating in this study"
                    }
                },
                "training-question-block": {
                    "kind": "exp-frame-select",
                    "frameOptions": [
                        {}, {}, {}, {}, {}, {}, {}, {}, {}, {}
                    ],
                    "commonFrameProperties": {
                        "kind": "exp-lookit-survey",
                        "generateProperties": "  function(expData, sequence, child, pastSessions) {                var n = Math.floor(Math.random() * Math.floor(20));                var m = Math.floor(Math.random() * Math.floor(20));                return {                    'formSchema': {                        'schema': {                            'type': 'object',                            'title': 'Math practice question',                            'properties': {                                'add': {                                    'enum': [                                       'low',                                        'correct',                                        'high'                                    ],    'title': 'What is ' + n + ' plus ' + m + '?',                                    'required': true                                }                            }                        },                        'options': {                            'fields': {                                'add': {                                    'type': 'radio',   'optionLabels': [n + m - 1, n + m, n + m + 1],                                 'message': 'Please answer this question.',                                    'validator': 'required-field'}}}}}}",
                        "selectNextFrame": "function(frames, frameIndex, frameData, expData, sequence, child, pastSessions) {    var testFrame = 0; for (var iFrame = 0; iFrame < frames.length; iFrame++) {if (frames[iFrame]['id'].indexOf('test-question') != -1) {testFrame = iFrame; break;}} if ((sequence.length >= 3) && (expData[sequence[sequence.length - 2]]['formData']['add'] == 'correct' ) && (expData[sequence[sequence.length - 1]]['formData']['add'] == 'correct')){     return testFrame;    }    else {        return frameIndex + 1;    }}"
                    }
                },
                "test-question": {
                    "kind": "exp-lookit-survey",
                    "generateProperties": "  function(expData, sequence, child, pastSessions) {                var n = Math.floor(Math.random() * Math.floor(20));                var m = Math.floor(Math.random() * Math.floor(20));                return {                    'formSchema': {                        'schema': {                            'type': 'object',                            'title': 'Math test question',                            'properties': {                                'subtract': {                                    'enum': [                                       'low',                                        'correct',                                        'high'                                    ],    'title': 'What is ' + n + ' minus ' + m + '?',                                    'required': true                                }                            }                        },                        'options': {                            'fields': {                                'subtract': {                                    'type': 'radio',   'optionLabels': [n - m - 1, n - m, n - m + 1],                                 'message': 'Please answer this question.',                                    'validator': 'required-field'}}}}}}"
                }
            },
            "sequence": [
                "training-question-block",
                "test-question",
                "exit-survey"
            ]
        }
        
        
There are three sections in the study: a block of up to 10 training questions, a single test question, and an exit survey. We use an ``exp-frame-select`` frame to quickly create ten identical training question frames, by putting all of the frame properties into ``commonFrameProperties``. We use ``generateProperties`` not to do anything contingent on the child or study data, but just to programmatically generate the questions - this way we can choose random numbers for each question. Finally, we add a ``selectNextFrame`` function to the training questions. Let's take a closer look at that function:

.. code:: js

        function(frames, frameIndex, frameData, expData, sequence, child, pastSessions) {
            // First, find the index of the test frame in case we need to go there
            var testFrame = 0;
            for (var iFrame = 0; iFrame < frames.length; iFrame++) {
                if (frames[iFrame]['id'].indexOf('test-question') != -1) {
                    testFrame = iFrame;
                    break;
                }
            }
            // If the last two questions were answered correctly, go to test
            if ((sequence.length >= 3) && (expData[sequence[sequence.length - 2]]['formData']['add'] == 'correct') && (expData[sequence[sequence.length - 1]]['formData']['add'] == 'correct')) {
                return testFrame;
            } else {
            // Otherwise, just go to the next frame
                return frameIndex + 1;
            }
        }

We first use the list of ``frames`` to identify the index of the test question. (In this case we could safely assume it's the second-to-last frame, too. But in a more complex experiment, we might want to find it like this.)

Then we check whether (a) there are already at least 3 frames including this one in the ``sequence`` (two practice questions plus the initial ``exp-frame-select`` frame) and (b) the last two questions including this one were answered correctly. If so, we skip right to the test question!

Example: personalized story
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One of the objects you have access to in your ``generateProperties`` function is the ``child``. This allows you to use child data in selecting stimuli, instructions, or procedures. A simple use case would be personalizing a story (or instructions) using the child's name and gender. Here's an example:

.. code:: json

        {
            "frames": {
                "personalized-story": {
                    "kind": "exp-lookit-text",
                    "generateProperties": "function(expData, sequence, child, pastSessions, conditions) {var childName = child.get('givenName'); var genderedChild; if (child.get('gender') == 'f') {    genderedChild = 'girl';} else if (child.get('gender') == 'm') {    genderedChild = 'boy';} else {genderedChild = 'kiddo';} var line1 = 'Once upon a time, there was a little ' + genderedChild + ' named ' + childName + '.'; var line2 = childName + ' loved to draw.'; return {'blocks': [{'text': line1}, {'text': line2}]};}"
                }
            },
            "sequence": [
                "personalized-story"
            ]
        }


Example: debriefing text that depends on experimental condition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One fairly common and straightforward use case for customizing frames based on data from the experiment is that you might like to debrief parents at the end of the study based on the experimental condition their child was in, just like you would in the lab. 

Here's an example where we have an experimental "procedure" that depends on condition assignment in a ``random-parameter-set`` frame, and mention the condition in the debriefing text:

.. code:: json

        {
            "frames": {
                "exit-survey": {
                    "kind": "exp-lookit-exit-survey",
                    "debriefing": {
                        "title": "Thank you!",
                        "text": "Thank you for participating in this study. Your child was in the "
                    },
                    "generateProperties": "function(expData, sequence, child, pastSessions, conditions) {if (conditions['1-study-procedure']['conditionNum'] == 0) {return {'debriefing': {'title': 'Thank you!', 'text': 'Your child was in the cats condition.'}};} else  {return {'debriefing': {'title': 'Thank you!', 'text': 'Your child was in the dogs condition.'}};} }"
                },
                "study-procedure": {
                    "sampler": "random-parameter-set",
                    "kind": "choice",
                    "frameList": [
                        {
                            "kind": "exp-lookit-text",
                            "blocks": [
                                {
                                    "text": "PROCEDURE_TEXT",
                                    "title": "PROCEDURE_TITLE"
                                }
                            ]
                        }
                    ],
                    "parameterSets": [
                        {
                            "PROCEDURE_TEXT": "All about cats",
                            "PROCEDURE_TITLE": "Cats say meow!"
                        },
                        {
                            "PROCEDURE_TEXT": "All about dogs",
                            "PROCEDURE_TITLE": "Dogs say woof!"
                        }
                    ]
                }
            },
            "sequence": [
                "study-procedure",
                "exit-survey"
            ]
        }
        
Your debriefing information could also take into account other factors - for instance, if you were conducting a give-N task, you could actually give an automatic estimate of the child's knower-level or show a chart of their responses! As an exercise, try personalizing the debriefing text to use the child's name.